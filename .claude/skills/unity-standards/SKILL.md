---
name: unity-standards
description: C# coding standards, Unity-specific patterns, error handling, workflow requirements, and token-efficient implementation strategies. Use when writing or reviewing C# scripts for Unity, implementing new systems, or dealing with editor workflows.
---

# Unity Development Standards & Patterns

## Unity Development Workflow - CRITICAL

**ALWAYS follow this workflow when making Unity changes:**

### Before ANY commits involving Unity:
1. **REMIND USER TO SAVE IN UNITY FIRST**
   - User must: File → Save (Ctrl+S) to save active scene
   - User must: File → Save Project to save all assets
   - Then: Check `git status` to see what Unity changed

### Unity-Specific Considerations:
- Scene files (.unity) only update when saved in Unity Editor
- Prefabs (.prefab) only update when saved in Unity Editor
- ScriptableObjects (.asset) only update when saved in Unity Editor
- .meta files are auto-generated by Unity - always commit them with their corresponding files
- Library/ folder contains Unity cache - never commit (already in .gitignore)

### Testing in Unity:
- User tests changes by pressing Play button in Unity Editor
- Console window shows Debug.Log output and errors
- Compilation errors prevent Play mode - must fix first
- Scene view shows visual representation, Game view shows player perspective

### Common Unity Pitfalls:
- Adding components via script (AddComponent) requires Initialize() calls for ScriptableObject references
- Deleting C# files requires removing .meta files to prevent CS2001 errors
- Unity caches compiled scripts in Library/ - sometimes needs Editor refresh

---

## C# and Unity Standards

### General C# Principles
- Follow .NET naming conventions (PascalCase for public members, camelCase for private)
- Use nullable reference types where appropriate
- Prefer LINQ for collection operations
- Use async/await for I/O operations (save/load)
- Implement IDisposable when managing resources

### Unity-Specific Patterns
- **Singleton Managers**: Use standard Unity singleton pattern for all managers
- **ScriptableObject Definitions**: All game data (machines, materials) as SOs
- **MonoBehaviour Lifecycle**: Understand Awake/Start/Update/OnDestroy
- **Prefabs**: Use for reusable game objects (machines, workers, UI elements)
- **Event-Driven Architecture**: Use UnityEvents/custom events for decoupling (minimize for MVP)

### Code Organization
- One class per file (match filename to class name)
- Use namespaces that match folder structure
- Keep methods focused and testable
- Group related functionality into managers

### Modern C# Features
- Use pattern matching for type checks
- Leverage null-coalescing and null-conditional operators (`?.`, `??`)
- Apply `using` declarations for resource management
- Use expression-bodied members for simple properties

### Error Handling Pattern
```csharp
// Use specific exceptions with proper logging
public void LoadFactory(string levelID)
{
    if (string.IsNullOrWhiteSpace(levelID))
        throw new ArgumentException("Level ID cannot be empty", nameof(levelID));

    try
    {
        var saveData = SaveSystem.LoadFactoryData(levelID);
        ApplySaveData(saveData);
    }
    catch (System.IO.FileNotFoundException)
    {
        Debug.LogWarning($"No save data found for level {levelID}, starting fresh");
        InitializeNewFactory(levelID);
    }
    catch (Exception ex)
    {
        Debug.LogError($"Failed to load factory: {ex.Message}");
        throw;
    }
}
```

---

## Token-Efficient Implementation Strategy

When asking for implementation help:

1. **Reference specific sections**: "Implement the `IdleCalculator` system described in claude.md Phase 1"
2. **One system at a time**: Don't ask for entire managers, focus on single features
3. **Provide context**: "We're in Phase 1 MVP, workers are simplified (no attributes yet)"
4. **Request incremental**: "Start with basic inventory tracking, we'll add auto-reorder later"

### Common Patterns to Reuse
- **Singleton Managers**: Use standard Unity singleton pattern for all managers
- **ScriptableObject Definitions**: All game data (machines, materials) as SOs
- **Event-Driven Architecture**: Use UnityEvents/custom events for decoupling (minimize for MVP)
